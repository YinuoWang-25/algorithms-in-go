# 314. Binary Tree Vertical Order Traversal

### Description

Given a binary tree, return the vertical order traversal of its nodes' values. \(ie, from top to bottom, column by column\).

If two nodes are in the same row and column, the order should be from **left to right**.

### Examples

**Examples 1:**

```text
Input: [3,9,20,null,null,15,7]

   3
  /\\
 /  \\
 9  20
    /\\
   /  \\
  15   7 

Output:

[
  [9],
  [3,15],
  [20],
  [7]
]

```

**Examples 2:**

```text
Input: [3,9,8,4,0,1,7]

     3
    /\\
   /  \\
   9   8
  /\\  /\\
 /  \\/  \\
 4  01   7 

Output:

[
  [4],
  [9],
  [3,0,1],
  [8],
  [7]
]

```

**Examples 3:**

```text
Input: [3,9,8,4,0,1,7,null,null,null,2,5] (0's right child is 2 and 1's left child is 5)

     3
    /\
   /  \
   9   8
  /\  /\
 /  \/  \
 4  01   7
    /\
   /  \
   5   2

Output:

[
  [4],
  [9,5],
  [3,0,1],
  [8,2],
  [7]
]
```

### Solutions

{% tabs %}
{% tab title="Java" %}
```java
public List<List<Integer>> levelOrder(Node root) {
    LinkedList<List<Integer>> res = new LinkedList<>();
    if (root == null) {
        return res;
    }
    Queue<Node> q = new LinkedList<>();
    q.add(root);
    while (q.size() > 0) {
        int sz = q.size();
        LinkedList<Integer> curLevel = new LinkedList<Integer>();
        while (sz > 0) {
            Node curNode = q.poll();
            curLevel.add(curNode.val);
            for (Node child : curNode.children) {
                q.offer(child);
            }
            sz--;
        }
        res.add(curLevel);
    }
    return res;
}
```
{% endtab %}

{% tab title="GoLang" %}
```go
func verticalOrder(root *TreeNode) [][]int {
	var res [][]int

	if root == nil {
		return res
	}

	var queue []*TreeNode
	var colQueue []int
	// attention: need to use make instead of :=
	hash := make(map[int][]int)

	queue = append(queue, root)
	colQueue = append(colQueue, 0)

	min, max := 0, 0


	for len(queue) != 0 {
		curTreeNode := queue[0]
		curCol := colQueue[0]
		queue = queue[1:]
		colQueue = colQueue[1:]

		min = int(math.Min(float64(min), float64(curCol)))
		max = int(math.Max(float64(max), float64(curCol)))
		if _, ok := hash[curCol]; !ok {
			hash[curCol] = []int{}
		}
		hash[curCol] = append(hash[curCol], curTreeNode.Val)

		if curTreeNode.Left != nil {
			queue = append(queue, (*TreeNode)(curTreeNode.Left))
			colQueue = append(colQueue, curCol - 1)
		}
		if curTreeNode.Right != nil {
			queue = append(queue, (*TreeNode)(curTreeNode.Right))
			colQueue = append(colQueue, curCol + 1)
		}
	}
	for i := min; i<= max; i++ {
		res = append(res, hash[i])
	}
	return res
}
```
{% endtab %}
{% endtabs %}


# 101. Symmetric Tree

### Description

Given a binary tree, check whether it is a mirror of itself \(ie, symmetric around its center\).

For example, this binary tree `[1,2,2,3,4,4,3]` is symmetric:

```text
    1
   / \\
  2   2
 / \\ / \\
3  4 4  3

```

But the following `[1,2,2,null,3,null,3]` is not:

```text
    1
   / \\
  2   2
   \\   \\
   3    3

```

### **Follow up**

Solve it both recursively and iteratively.

### Solutions

{% tabs %}
{% tab title="Java - Recursive" %}
```text

```
{% endtab %}

{% tab title="Java - Iterative" %}
```

```
{% endtab %}

{% tab title="GoLang - Recursive" %}
```go
func isSymmetric(root *TreeNode) bool {
  if root == nil {
    return true
  }
	return checkSymmetric(root.Left, root.Right)
}

func checkSymmetric(p *TreeNode, q *TreeNode) bool {
	if p == nil && q == nil {
		return true
	}
	if p == nil || q == nil || p.Val != q.Val {
		return false
	}
	return checkSymmetric(p.Left, q.Right) && checkSymmetric(p.Right, q.Left)
}
```
{% endtab %}

{% tab title="GoLang - Iterative" %}
```go
func isSymmetric(root *TreeNode) bool {
    if root == nil {
		return true
	}
	var queue []*TreeNode
	queue = append(queue, root.Left)
	queue = append(queue, root.Right)
	for len(queue) > 0 {
		first := queue[0]
		second := queue[1]
		queue = queue[2:]
		if first == nil && second == nil {
			continue
		} else if first == nil || second == nil || first.Val != second.Val {
			return false
		} else {
			queue = append(queue, first.Left)
			queue = append(queue, second.Right)
			queue = append(queue, second.Left)
			queue = append(queue, first.Right)
		}
	}
	return true
}
```
{% endtab %}
{% endtabs %}

